{-# Language OverloadedStrings #-}
{-# Language LambdaCase #-}
{-# Language RecordWildCards #-}
{-# Language DuplicateRecordFields #-}

module TestData where

import Data.Text (Text)
import Data.Map.Lazy (Map)
import qualified Data.Map.Lazy as Map
import Lean.IR
import Lean.AST hiding (Param,Lit, Literal(..), Name, Proj)
import Lean.AST qualified as AST

filterOutDecl :: Map Text Out -> Map Text Decl
filterOutDecl = Map.map (\case
                        Decl d      -> d
                        DeclT _ _ d -> d
                        ConInfo _   -> error "") . Map.filter (\case
                          Decl _      -> True
                          DeclT _ _ _ -> True
                          ConInfo _   -> False)

n :: Decl
n = case Map.lookup "Examples.Bool.not" boolDef of Just (x) -> x; _ -> error "";

o :: Decl
o = case Map.lookup "Examples.Bool.or" boolDef of Just (x) -> x; _ -> error "";

a :: Decl
a = case Map.lookup "Examples.Bool.and" boolDef of Just (x) -> x; _ -> error "";

t :: Val
t = Unsigned 0

f :: Val
f = Unsigned 1

boolDef :: Map Text Decl
boolDef = filterOutDecl $ Map.fromList [("Examples.Bool.B",ConInfo (Def {name = "Examples.Bool.B", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Examples.Bool.B.t","Examples.Bool.B.f"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Examples.Bool.B.f",ConInfo (Def {name = "Examples.Bool.B.f", levelParams = [], typ = Const {name = "Examples.Bool.B", levels = []}, kind = Constructor {induct = "Examples.Bool.B", cidx = 1, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Bool.B.t",ConInfo (Def {name = "Examples.Bool.B.t", levelParams = [], typ = Const {name = "Examples.Bool.B", levels = []}, kind = Constructor {induct = "Examples.Bool.B", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Bool.and",DeclT (ForAllE {binder = "a._@.Examples.Bool._hyg.34", typ = Const {name = "Examples.Bool.B", levels = []}, body = ForAllE {binder = "a._@.Examples.Bool._hyg.36", typ = Const {name = "Examples.Bool.B", levels = []}, body = Const {name = "Examples.Bool.B", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Examples.Bool.and", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = U8},Param {x = VarId {idx = 2}, borrow = False, typ = U8}], typ = U8, bod = Case {tid = "Examples.Bool.B", x = VarId {idx = 1}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Examples.Bool.B.t", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Ret {r = Var {i = VarId {idx = 2}}}},Ctor {info = CtorInfo {name = "Examples.Bool.B.f", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = Lit {v = N 1}, b = Ret {r = Var {i = VarId {idx = 3}}}}}]}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Bool.not",DeclT (ForAllE {binder = "b", typ = Const {name = "Examples.Bool.B", levels = []}, body = Const {name = "Examples.Bool.B", levels = []}, info = BDefault}) [] (FDecl {f = "Examples.Bool.not", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = U8}], typ = U8, bod = Case {tid = "Examples.Bool.B", x = VarId {idx = 1}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Examples.Bool.B.t", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 2}, typ = U8, e = Lit {v = N 1}, b = Ret {r = Var {i = VarId {idx = 2}}}}},Ctor {info = CtorInfo {name = "Examples.Bool.B.f", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = Lit {v = N 0}, b = Ret {r = Var {i = VarId {idx = 3}}}}}]}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Bool.or",DeclT (ForAllE {binder = "a._@.Examples.Bool._hyg.57", typ = Const {name = "Examples.Bool.B", levels = []}, body = ForAllE {binder = "a._@.Examples.Bool._hyg.59", typ = Const {name = "Examples.Bool.B", levels = []}, body = Const {name = "Examples.Bool.B", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Examples.Bool.or", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = U8},Param {x = VarId {idx = 2}, borrow = False, typ = U8}], typ = U8, bod = Case {tid = "Examples.Bool.B", x = VarId {idx = 1}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Examples.Bool.B.t", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = Lit {v = N 0}, b = Ret {r = Var {i = VarId {idx = 3}}}}},Ctor {info = CtorInfo {name = "Examples.Bool.B.f", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Ret {r = Var {i = VarId {idx = 2}}}}]}, info = DeclInfo {sorryDep = Nothing}}))]


add :: Decl
add = case Map.lookup "Examples.Nat.add" natDef of Just (x) -> x; _ -> error "";

sub :: Decl
sub = case Map.lookup "Examples.Nat.sub" natDef of Just (x) -> x; _ -> error "";

zero :: Val
zero = VCtor { o = Object { rc = 1, tag = 0 }, vs = [] }

one :: Val
one = VCtor { o = Object { rc = 1, tag = 1 }, vs = [zero] }

two :: Val
two = VCtor { o = Object { rc = 1, tag = 1 }, vs = [one] }

intToValPeano :: Int -> Val
intToValPeano 0 = zero
intToValPeano n = VCtor { o = Object { rc = 1, tag = 1 }, vs = [intToValPeano (n-1)] }

natDef :: Map Name Decl
natDef = filterOutDecl $ Map.fromList [("And",ConInfo (Def {name = "And", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "b", typ = Sort {level = Zero}, body = Sort {level = Zero}, info = BDefault}, info = BDefault}, kind = Inductive {numParams = 2, numIndices = 0, ctors = ["And.intro"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("And.intro",ConInfo (Def {name = "And.intro", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "b", typ = Sort {level = Zero}, body = ForAllE {binder = "left", typ = Bvar {index = 1}, body = ForAllE {binder = "right", typ = Bvar {index = 1}, body = App {function = App {function = Const {name = "And", levels = []}, arg = Bvar {index = 3}}, arg = Bvar {index = 2}}, info = BDefault}, info = BDefault}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "And", cidx = 0, numParams = 2, arity = 2, isUnsafe = False}})),("BitVec",ConInfo (Def {name = "BitVec", levelParams = [], typ = ForAllE {binder = "w", typ = Const {name = "Nat", levels = []}, body = Sort {level = Succ Zero}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["BitVec.ofFin"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("BitVec.ofFin",ConInfo (Def {name = "BitVec.ofFin", levelParams = [], typ = ForAllE {binder = "w", typ = Const {name = "Nat", levels = []}, body = ForAllE {binder = "toFin", typ = App {function = Const {name = "Fin", levels = []}, arg = App {function = App {function = App {function = App {function = App {function = App {function = Const {name = "HPow.hPow", levels = [Zero,Zero,Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "Nat", levels = []}}, arg = App {function = App {function = App {function = Const {name = "instHPow", levels = [Zero,Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "Nat", levels = []}}, arg = App {function = App {function = Const {name = "instPowNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "instNatPowNat", levels = []}}}}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 2}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 2}}}}, arg = Bvar {index = 0}}}, body = App {function = Const {name = "BitVec", levels = []}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "BitVec", cidx = 0, numParams = 1, arity = 1, isUnsafe = False}})),("Bool",ConInfo (Def {name = "Bool", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Bool.false","Bool.true"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Bool.false",ConInfo (Def {name = "Bool.false", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Bool.true",ConInfo (Def {name = "Bool.true", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 1, numParams = 0, arity = 0, isUnsafe = False}})),("Char",ConInfo (Def {name = "Char", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Char.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Char.mk",ConInfo (Def {name = "Char.mk", levelParams = [], typ = ForAllE {binder = "val", typ = Const {name = "UInt32", levels = []}, body = ForAllE {binder = "valid", typ = App {function = Const {name = "UInt32.isValidChar", levels = []}, arg = Bvar {index = 0}}, body = Const {name = "Char", levels = []}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Char", cidx = 0, numParams = 0, arity = 2, isUnsafe = False}})),("Decidable",ConInfo (Def {name = "Decidable", levelParams = [], typ = ForAllE {binder = "p", typ = Sort {level = Zero}, body = Sort {level = Succ Zero}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["Decidable.isFalse","Decidable.isTrue"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Decidable.isFalse",ConInfo (Def {name = "Decidable.isFalse", levelParams = [], typ = ForAllE {binder = "p", typ = Sort {level = Zero}, body = ForAllE {binder = "h", typ = App {function = Const {name = "Not", levels = []}, arg = Bvar {index = 0}}, body = App {function = Const {name = "Decidable", levels = []}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "Decidable", cidx = 0, numParams = 1, arity = 1, isUnsafe = False}})),("Decidable.isTrue",ConInfo (Def {name = "Decidable.isTrue", levelParams = [], typ = ForAllE {binder = "p", typ = Sort {level = Zero}, body = ForAllE {binder = "h", typ = Bvar {index = 0}, body = App {function = Const {name = "Decidable", levels = []}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "Decidable", cidx = 1, numParams = 1, arity = 1, isUnsafe = False}})),("Examples.Nat.N",ConInfo (Def {name = "Examples.Nat.N", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Examples.Nat.N.Z","Examples.Nat.N.S"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("Examples.Nat.N.S",ConInfo (Def {name = "Examples.Nat.N.S", levelParams = [], typ = ForAllE {binder = "a._@.Examples.Nat._hyg.7", typ = Const {name = "Examples.Nat.N", levels = []}, body = Const {name = "Examples.Nat.N", levels = []}, info = BDefault}, kind = Constructor {induct = "Examples.Nat.N", cidx = 1, numParams = 0, arity = 1, isUnsafe = False}})),("Examples.Nat.N.Z",ConInfo (Def {name = "Examples.Nat.N.Z", levelParams = [], typ = Const {name = "Examples.Nat.N", levels = []}, kind = Constructor {induct = "Examples.Nat.N", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Nat.add",DeclT (ForAllE {binder = "n", typ = Const {name = "Examples.Nat.N", levels = []}, body = ForAllE {binder = "m", typ = Const {name = "Examples.Nat.N", levels = []}, body = Const {name = "Examples.Nat.N", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Examples.Nat.add", xs = [Param {x = VarId {idx = 1}, borrow = True, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj}], typ = Obj, bod = Case {tid = "Examples.Nat.N", x = VarId {idx = 2}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.Nat.N.Z", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Inc {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 1}}}}},Ctor {info = CtorInfo {name = "Examples.Nat.N.S", cidx = 1, size = 1, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = IsShared {x = VarId {idx = 2}}, b = Case {tid = "Bool", x = VarId {idx = 3}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 2}}, b = Vdecl {x = VarId {idx = 5}, typ = Obj, e = Fap {c = "Examples.Nat.add", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 4}}]}, b = Set {x = VarId {idx = 2}, i = 0, a = Var {i = VarId {idx = 5}}, b = Ret {r = Var {i = VarId {idx = 2}}}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 6}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 2}}, b = Inc {x = VarId {idx = 6}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 2}, n = 1, c = True, persistent = False, b = Vdecl {x = VarId {idx = 7}, typ = Obj, e = Fap {c = "Examples.Nat.add", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 6}}]}, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.Nat.N.S", cidx = 1, size = 1, usize = 0, ssize = 0}, ys = [Var {i = VarId {idx = 7}}]}, b = Ret {r = Var {i = VarId {idx = 8}}}}}}}}}]}}}]}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub",DeclT (ForAllE {binder = "a._@.Examples.Nat._hyg.136", typ = Const {name = "Examples.Nat.N", levels = []}, body = ForAllE {binder = "a._@.Examples.Nat._hyg.138", typ = Const {name = "Examples.Nat.N", levels = []}, body = Const {name = "Examples.Nat.N", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Examples.Nat.sub", xs = [Param {x = VarId {idx = 1}, borrow = True, typ = Obj},Param {x = VarId {idx = 2}, borrow = True, typ = Obj}], typ = Obj, bod = Case {tid = "Examples.Nat.N", x = VarId {idx = 1}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.Nat.N.Z", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = Lit {v = N 0}, b = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_19", ys = []}, b = Vdecl {x = VarId {idx = 5}, typ = Obj, e = Fap {c = "sorryAx", ys = [Irr,Var {i = VarId {idx = 3}}]}, b = Vdecl {x = VarId {idx = 6}, typ = Obj, e = Ap {x = VarId {idx = 5}, ys = [Var {i = VarId {idx = 4}}]}, b = Ret {r = Var {i = VarId {idx = 6}}}}}}}},Ctor {info = CtorInfo {name = "Examples.Nat.N.S", cidx = 1, size = 1, usize = 0, ssize = 0}, b = Case {tid = "Examples.Nat.N", x = VarId {idx = 2}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.Nat.N.Z", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Inc {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 1}}}}},Ctor {info = CtorInfo {name = "Examples.Nat.N.S", cidx = 1, size = 1, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 7}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 2}}, b = Vdecl {x = VarId {idx = 9}, typ = Obj, e = Fap {c = "Examples.Nat.sub", ys = [Var {i = VarId {idx = 7}},Var {i = VarId {idx = 8}}]}, b = Ret {r = Var {i = VarId {idx = 9}}}}}}}]}}]}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_1",Decl (FDecl {f = "Examples.Nat.sub._closed_1", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = S "Examples"}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_10",Decl (FDecl {f = "Examples.Nat.sub._closed_10", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_9", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 18}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_11",Decl (FDecl {f = "Examples.Nat.sub._closed_11", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = S "_sorry"}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_12",Decl (FDecl {f = "Examples.Nat.sub._closed_12", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_10", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_11", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_13",Decl (FDecl {f = "Examples.Nat.sub._closed_13", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = S "_@"}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_14",Decl (FDecl {f = "Examples.Nat.sub._closed_14", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_12", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_13", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_15",Decl (FDecl {f = "Examples.Nat.sub._closed_15", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_14", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_1", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_16",Decl (FDecl {f = "Examples.Nat.sub._closed_16", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_15", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_3", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_17",Decl (FDecl {f = "Examples.Nat.sub._closed_17", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = S "_hyg"}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_18",Decl (FDecl {f = "Examples.Nat.sub._closed_18", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_16", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_17", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_19",Decl (FDecl {f = "Examples.Nat.sub._closed_19", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_18", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 173}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_2",Decl (FDecl {f = "Examples.Nat.sub._closed_2", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = ECtor {info = CtorInfo {name = "Lean.Name.anonymous._impl", cidx = 0, size = 0, usize = 0, ssize = 0}, ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_1", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_3",Decl (FDecl {f = "Examples.Nat.sub._closed_3", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = S "Nat"}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_4",Decl (FDecl {f = "Examples.Nat.sub._closed_4", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_2", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_3", ys = []}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.str._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_5",Decl (FDecl {f = "Examples.Nat.sub._closed_5", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_4", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 26}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_6",Decl (FDecl {f = "Examples.Nat.sub._closed_6", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_5", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 13}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_7",Decl (FDecl {f = "Examples.Nat.sub._closed_7", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_6", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 26}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_8",Decl (FDecl {f = "Examples.Nat.sub._closed_8", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_7", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 18}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.Nat.sub._closed_9",Decl (FDecl {f = "Examples.Nat.sub._closed_9", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "Examples.Nat.sub._closed_8", ys = []}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Lit {v = N 13}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Lean.Name.num._override", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("False",ConInfo (Def {name = "False", levelParams = [], typ = Sort {level = Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = [], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Fin",ConInfo (Def {name = "Fin", levelParams = [], typ = ForAllE {binder = "n", typ = Const {name = "Nat", levels = []}, body = Sort {level = Succ Zero}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["Fin.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Fin.mk",ConInfo (Def {name = "Fin.mk", levelParams = [], typ = ForAllE {binder = "n", typ = Const {name = "Nat", levels = []}, body = ForAllE {binder = "val", typ = Const {name = "Nat", levels = []}, body = ForAllE {binder = "isLt", typ = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "instLTNat", levels = []}}, arg = Bvar {index = 0}}, arg = Bvar {index = 1}}, body = App {function = Const {name = "Fin", levels = []}, arg = Bvar {index = 2}}, info = BDefault}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "Fin", cidx = 0, numParams = 1, arity = 2, isUnsafe = False}})),("HPow",ConInfo (Def {name = "HPow", levelParams = ["u","v","w"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = ForAllE {binder = "\947", typ = App {function = Const {name = "outParam", levels = [Succ (Succ (AST.Param "w"))]}, arg = Sort {level = Succ (AST.Param "w")}}, body = Sort {level = Max (Max (Succ (AST.Param "u")) (Succ (AST.Param "v"))) (Succ (AST.Param "w"))}, info = BDefault}, info = BDefault}, info = BDefault}, kind = Inductive {numParams = 3, numIndices = 0, ctors = ["HPow.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("HPow.hPow",ConInfo (Def {name = "HPow.hPow", levelParams = ["u","v","w"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = ForAllE {binder = "\947", typ = App {function = Const {name = "outParam", levels = [Succ (Succ (AST.Param "w"))]}, arg = Sort {level = Succ (AST.Param "w")}}, body = ForAllE {binder = "self", typ = App {function = App {function = App {function = Const {name = "HPow", levels = [AST.Param "u",AST.Param "v",AST.Param "w"]}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2631", typ = Bvar {index = 3}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2633", typ = Bvar {index = 3}, body = Bvar {index = 3}, info = BDefault}, info = BDefault}, info = BInstance}, info = BImplicit}, info = BImplicit}, info = BImplicit}, kind = Definitional {val = Lam {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Lam {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = Lam {binder = "\947", typ = App {function = Const {name = "outParam", levels = [Succ (Succ (AST.Param "w"))]}, arg = Sort {level = Succ (AST.Param "w")}}, body = Lam {binder = "self", typ = App {function = App {function = App {function = Const {name = "HPow", levels = [AST.Param "u",AST.Param "v",AST.Param "w"]}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}, body = AST.Proj {name = "HPow", idx = 0, struct = Bvar {index = 0}}, info = BInstance}, info = BImplicit}, info = BDefault}, info = BDefault}, safety = Safe}})),("HPow.mk",ConInfo (Def {name = "HPow.mk", levelParams = ["u","v","w"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = ForAllE {binder = "\947", typ = App {function = Const {name = "outParam", levels = [Succ (Succ (AST.Param "w"))]}, arg = Sort {level = Succ (AST.Param "w")}}, body = ForAllE {binder = "hPow", typ = ForAllE {binder = "a._@.Init.Prelude._hyg.2631", typ = Bvar {index = 2}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2633", typ = Bvar {index = 2}, body = Bvar {index = 2}, info = BDefault}, info = BDefault}, body = App {function = App {function = App {function = Const {name = "HPow", levels = [AST.Param "u",AST.Param "v",AST.Param "w"]}, arg = Bvar {index = 3}}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "HPow", cidx = 0, numParams = 3, arity = 1, isUnsafe = False}})),("LT",ConInfo (Def {name = "LT", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Sort {level = Succ (AST.Param "u")}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["LT.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("LT.lt",ConInfo (Def {name = "LT.lt", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "self", typ = App {function = Const {name = "LT", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2264", typ = Bvar {index = 1}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2266", typ = Bvar {index = 2}, body = Sort {level = Zero}, info = BDefault}, info = BDefault}, info = BInstance}, info = BImplicit}, kind = Definitional {val = Lam {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Lam {binder = "self", typ = App {function = Const {name = "LT", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, body = AST.Proj {name = "LT", idx = 0, struct = Bvar {index = 0}}, info = BInstance}, info = BDefault}, safety = Safe}})),("LT.mk",ConInfo (Def {name = "LT.mk", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "lt", typ = ForAllE {binder = "a._@.Init.Prelude._hyg.2264", typ = Bvar {index = 0}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2266", typ = Bvar {index = 1}, body = Sort {level = Zero}, info = BDefault}, info = BDefault}, body = App {function = Const {name = "LT", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "LT", cidx = 0, numParams = 1, arity = 1, isUnsafe = False}})),("Lean.Name",ConInfo (Def {name = "Lean.Name", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Lean.Name.anonymous","Lean.Name.str","Lean.Name.num"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("Lean.Name._impl",ConInfo (Def {name = "Lean.Name._impl", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Lean.Name.anonymous._impl","Lean.Name.str._impl","Lean.Name.num._impl"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Lean.Name.anonymous",ConInfo (Def {name = "Lean.Name.anonymous", levelParams = [], typ = Const {name = "Lean.Name", levels = []}, kind = Constructor {induct = "Lean.Name", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Lean.Name.anonymous._impl",ConInfo (Def {name = "Lean.Name.anonymous._impl", levelParams = [], typ = Const {name = "Lean.Name._impl", levels = []}, kind = Constructor {induct = "Lean.Name._impl", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Lean.Name.hash._override",DeclT (ForAllE {binder = "x", typ = Const {name = "Lean.Name", levels = []}, body = Const {name = "UInt64", levels = []}, info = BDefault}) [] (FDecl {f = "Lean.Name.hash._override", xs = [Param {x = VarId {idx = 1}, borrow = True, typ = Obj}], typ = U64, bod = Case {tid = "Lean.Name._impl", x = VarId {idx = 1}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Lean.Name.anonymous._impl", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 2}, typ = U64, e = Fap {c = "Lean.Name.hash._override._closed_1", ys = []}, b = Ret {r = Var {i = VarId {idx = 2}}}}},Default {b = Vdecl {x = VarId {idx = 3}, typ = U64, e = Sproj {n = 2, offset = 0, x = VarId {idx = 1}}, b = Ret {r = Var {i = VarId {idx = 3}}}}}]}, info = DeclInfo {sorryDep = Nothing}})),("Lean.Name.hash._override._closed_1",Decl (FDecl {f = "Lean.Name.hash._override._closed_1", xs = [], typ = U64, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = N 1723}, b = Vdecl {x = VarId {idx = 2}, typ = U64, e = Fap {c = "UInt64.ofNatCore", ys = [Var {i = VarId {idx = 1}},Irr]}, b = Ret {r = Var {i = VarId {idx = 2}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Lean.Name.num",ConInfo (Def {name = "Lean.Name.num", levelParams = [], typ = ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "i", typ = Const {name = "Nat", levels = []}, body = Const {name = "Lean.Name", levels = []}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Lean.Name", cidx = 2, numParams = 0, arity = 2, isUnsafe = False}})),("Lean.Name.num._impl",ConInfo (Def {name = "Lean.Name.num._impl", levelParams = [], typ = ForAllE {binder = "hash", typ = Const {name = "UInt64", levels = []}, body = ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "i", typ = Const {name = "Nat", levels = []}, body = Const {name = "Lean.Name._impl", levels = []}, info = BDefault}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Lean.Name._impl", cidx = 2, numParams = 0, arity = 3, isUnsafe = False}})),("Lean.Name.num._override",DeclT (ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "i", typ = Const {name = "Nat", levels = []}, body = Const {name = "Lean.Name", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Lean.Name.num._override", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 3}, typ = U64, e = Fap {c = "Lean.Name.hash._override", ys = [Var {i = VarId {idx = 1}}]}, b = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Fap {c = "UInt64.size._closed_1", ys = []}, b = Vdecl {x = VarId {idx = 5}, typ = U8, e = Fap {c = "Nat.decLt", ys = [Var {i = VarId {idx = 2}},Var {i = VarId {idx = 4}}]}, b = Dec {x = VarId {idx = 4}, n = 1, c = True, persistent = True, b = Case {tid = "Bool", x = VarId {idx = 5}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 6}, typ = U64, e = Fap {c = "Lean.Name.num._override._closed_1", ys = []}, b = Vdecl {x = VarId {idx = 7}, typ = U64, e = Fap {c = "mixHash", ys = [Var {i = VarId {idx = 3}},Var {i = VarId {idx = 6}}]}, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = ECtor {info = CtorInfo {name = "Lean.Name.num._impl", cidx = 2, size = 2, usize = 0, ssize = 8}, ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Sset {x = VarId {idx = 8}, i = 2, offset = 0, y = VarId {idx = 7}, ty = U64, b = Ret {r = Var {i = VarId {idx = 8}}}}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 9}, typ = U64, e = Fap {c = "UInt64.ofNatCore", ys = [Var {i = VarId {idx = 2}},Irr]}, b = Vdecl {x = VarId {idx = 10}, typ = U64, e = Fap {c = "mixHash", ys = [Var {i = VarId {idx = 3}},Var {i = VarId {idx = 9}}]}, b = Vdecl {x = VarId {idx = 11}, typ = Obj, e = ECtor {info = CtorInfo {name = "Lean.Name.num._impl", cidx = 2, size = 2, usize = 0, ssize = 8}, ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Sset {x = VarId {idx = 11}, i = 2, offset = 0, y = VarId {idx = 10}, ty = U64, b = Ret {r = Var {i = VarId {idx = 11}}}}}}}}]}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Lean.Name.num._override._closed_1",Decl (FDecl {f = "Lean.Name.num._override._closed_1", xs = [], typ = U64, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = N 17}, b = Vdecl {x = VarId {idx = 2}, typ = U64, e = Fap {c = "UInt64.ofNatCore", ys = [Var {i = VarId {idx = 1}},Irr]}, b = Ret {r = Var {i = VarId {idx = 2}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Lean.Name.str",ConInfo (Def {name = "Lean.Name.str", levelParams = [], typ = ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "str", typ = Const {name = "String", levels = []}, body = Const {name = "Lean.Name", levels = []}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Lean.Name", cidx = 1, numParams = 0, arity = 2, isUnsafe = False}})),("Lean.Name.str._impl",ConInfo (Def {name = "Lean.Name.str._impl", levelParams = [], typ = ForAllE {binder = "hash", typ = Const {name = "UInt64", levels = []}, body = ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "str", typ = Const {name = "String", levels = []}, body = Const {name = "Lean.Name._impl", levels = []}, info = BDefault}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Lean.Name._impl", cidx = 1, numParams = 0, arity = 3, isUnsafe = False}})),("Lean.Name.str._override",DeclT (ForAllE {binder = "pre", typ = Const {name = "Lean.Name", levels = []}, body = ForAllE {binder = "str", typ = Const {name = "String", levels = []}, body = Const {name = "Lean.Name", levels = []}, info = BDefault}, info = BDefault}) [] (FDecl {f = "Lean.Name.str._override", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 3}, typ = U64, e = Fap {c = "Lean.Name.hash._override", ys = [Var {i = VarId {idx = 1}}]}, b = Vdecl {x = VarId {idx = 4}, typ = U64, e = Fap {c = "String.hash", ys = [Var {i = VarId {idx = 2}}]}, b = Vdecl {x = VarId {idx = 5}, typ = U64, e = Fap {c = "mixHash", ys = [Var {i = VarId {idx = 3}},Var {i = VarId {idx = 4}}]}, b = Vdecl {x = VarId {idx = 6}, typ = Obj, e = ECtor {info = CtorInfo {name = "Lean.Name.str._impl", cidx = 1, size = 2, usize = 0, ssize = 8}, ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Sset {x = VarId {idx = 6}, i = 2, offset = 0, y = VarId {idx = 5}, ty = U64, b = Ret {r = Var {i = VarId {idx = 6}}}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("List",ConInfo (Def {name = "List", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Sort {level = Succ (AST.Param "u")}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["List.nil","List.cons"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("List.cons",ConInfo (Def {name = "List.cons", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "head", typ = Bvar {index = 0}, body = ForAllE {binder = "tail", typ = App {function = Const {name = "List", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, body = App {function = Const {name = "List", levels = [AST.Param "u"]}, arg = Bvar {index = 2}}, info = BDefault}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "List", cidx = 1, numParams = 1, arity = 2, isUnsafe = False}})),("List.nil",ConInfo (Def {name = "List.nil", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = App {function = Const {name = "List", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, info = BImplicit}, kind = Constructor {induct = "List", cidx = 0, numParams = 1, arity = 0, isUnsafe = False}})),("Nat",ConInfo (Def {name = "Nat", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Nat.zero","Nat.succ"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("Nat.decLt",DeclT (ForAllE {binder = "n", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}, body = ForAllE {binder = "m", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}, body = App {function = Const {name = "Decidable", levels = []}, arg = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}}, arg = Const {name = "instLTNat", levels = []}}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}}, info = BDefault}, info = BDefault}) [] (Extern {f = "Nat.decLt", xs = [Param {x = VarId {idx = 0}, borrow = True, typ = Obj},Param {x = VarId {idx = 1}, borrow = True, typ = Obj}], typ = U8, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_nat_dec_lt"}]}})),("Nat.isValidChar",ConInfo (Def {name = "Nat.isValidChar", levelParams = [], typ = ForAllE {binder = "n", typ = Const {name = "Nat", levels = []}, body = Sort {level = Zero}, info = BDefault}, kind = Definitional {val = Lam {binder = "n", typ = Const {name = "Nat", levels = []}, body = App {function = App {function = Const {name = "Or", levels = []}, arg = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "instLTNat", levels = []}}, arg = Bvar {index = 0}}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 55296}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 55296}}}}}, arg = App {function = App {function = Const {name = "And", levels = []}, arg = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "instLTNat", levels = []}}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 57343}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 57343}}}}, arg = Bvar {index = 0}}}, arg = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Const {name = "instLTNat", levels = []}}, arg = Bvar {index = 0}}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 1114112}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 1114112}}}}}}, info = BDefault}, safety = Safe}})),("Nat.pow",DeclT (ForAllE {binder = "m", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.3522", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}, body = Const {name = "Nat", levels = []}, info = BDefault}, info = BDefault}) [] (Extern {f = "Nat.pow", xs = [Param {x = VarId {idx = 0}, borrow = True, typ = Obj},Param {x = VarId {idx = 1}, borrow = True, typ = Obj}], typ = Obj, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_nat_pow"}]}})),("Nat.pow._boxed",Decl (FDecl {f = "Nat.pow._boxed", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Nat.pow", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Dec {x = VarId {idx = 2}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 3}}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Nat.succ",ConInfo (Def {name = "Nat.succ", levelParams = [], typ = ForAllE {binder = "n", typ = Const {name = "Nat", levels = []}, body = Const {name = "Nat", levels = []}, info = BDefault}, kind = Constructor {induct = "Nat", cidx = 1, numParams = 0, arity = 1, isUnsafe = False}})),("Nat.zero",ConInfo (Def {name = "Nat.zero", levelParams = [], typ = Const {name = "Nat", levels = []}, kind = Constructor {induct = "Nat", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("NatPow",ConInfo (Def {name = "NatPow", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Sort {level = Succ (AST.Param "u")}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["NatPow.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("NatPow.mk",ConInfo (Def {name = "NatPow.mk", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "pow", typ = ForAllE {binder = "a._@.Init.Prelude._hyg.2836", typ = Bvar {index = 0}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2838", typ = Const {name = "Nat", levels = []}, body = Bvar {index = 2}, info = BDefault}, info = BDefault}, body = App {function = Const {name = "NatPow", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "NatPow", cidx = 0, numParams = 1, arity = 1, isUnsafe = False}})),("Not",ConInfo (Def {name = "Not", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = Sort {level = Zero}, info = BDefault}, kind = Definitional {val = Lam {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.158", typ = Bvar {index = 0}, body = Const {name = "False", levels = []}, info = BDefault}, info = BDefault}, safety = Safe}})),("OfNat",ConInfo (Def {name = "OfNat", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "x._@.Init.Prelude._hyg.2237", typ = Const {name = "Nat", levels = []}, body = Sort {level = Succ (AST.Param "u")}, info = BDefault}, info = BDefault}, kind = Inductive {numParams = 2, numIndices = 0, ctors = ["OfNat.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("OfNat.mk",ConInfo (Def {name = "OfNat.mk", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "x._@.Init.Prelude._hyg.2237", typ = Const {name = "Nat", levels = []}, body = ForAllE {binder = "ofNat", typ = Bvar {index = 1}, body = App {function = App {function = Const {name = "OfNat", levels = [AST.Param "u"]}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "OfNat", cidx = 0, numParams = 2, arity = 1, isUnsafe = False}})),("OfNat.ofNat",ConInfo (Def {name = "OfNat.ofNat", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "x._@.Init.Prelude._hyg.2237", typ = Const {name = "Nat", levels = []}, body = ForAllE {binder = "self", typ = App {function = App {function = Const {name = "OfNat", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}, body = Bvar {index = 2}, info = BInstance}, info = BDefault}, info = BImplicit}, kind = Definitional {val = Lam {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Lam {binder = "x._@.Init.Prelude._hyg.2237", typ = Const {name = "Nat", levels = []}, body = Lam {binder = "self", typ = App {function = App {function = Const {name = "OfNat", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}, body = AST.Proj {name = "OfNat", idx = 0, struct = Bvar {index = 0}}, info = BInstance}, info = BDefault}, info = BDefault}, safety = Safe}})),("Or",ConInfo (Def {name = "Or", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "b", typ = Sort {level = Zero}, body = Sort {level = Zero}, info = BDefault}, info = BDefault}, kind = Inductive {numParams = 2, numIndices = 0, ctors = ["Or.inl","Or.inr"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Or.inl",ConInfo (Def {name = "Or.inl", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "b", typ = Sort {level = Zero}, body = ForAllE {binder = "h", typ = Bvar {index = 1}, body = App {function = App {function = Const {name = "Or", levels = []}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "Or", cidx = 0, numParams = 2, arity = 1, isUnsafe = False}})),("Or.inr",ConInfo (Def {name = "Or.inr", levelParams = [], typ = ForAllE {binder = "a", typ = Sort {level = Zero}, body = ForAllE {binder = "b", typ = Sort {level = Zero}, body = ForAllE {binder = "h", typ = Bvar {index = 0}, body = App {function = App {function = Const {name = "Or", levels = []}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "Or", cidx = 1, numParams = 2, arity = 1, isUnsafe = False}})),("Pow",ConInfo (Def {name = "Pow", levelParams = ["u","v"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = Sort {level = Max (Succ (AST.Param "u")) (Succ (AST.Param "v"))}, info = BDefault}, info = BDefault}, kind = Inductive {numParams = 2, numIndices = 0, ctors = ["Pow.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Pow.mk",ConInfo (Def {name = "Pow.mk", levelParams = ["u","v"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "v")}, body = ForAllE {binder = "pow", typ = ForAllE {binder = "a._@.Init.Prelude._hyg.2827", typ = Bvar {index = 1}, body = ForAllE {binder = "a._@.Init.Prelude._hyg.2829", typ = Bvar {index = 1}, body = Bvar {index = 3}, info = BDefault}, info = BDefault}, body = App {function = App {function = Const {name = "Pow", levels = [AST.Param "u",AST.Param "v"]}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}, info = BImplicit}, kind = Constructor {induct = "Pow", cidx = 0, numParams = 2, arity = 1, isUnsafe = False}})),("String",ConInfo (Def {name = "String", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["String.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("String.hash",DeclT (ForAllE {binder = "s", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "String", levels = []}}, body = Const {name = "UInt64", levels = []}, info = BDefault}) [] (Extern {f = "String.hash", xs = [Param {x = VarId {idx = 0}, borrow = True, typ = Obj}], typ = U64, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_string_hash"}]}})),("String.mk",DeclT (ForAllE {binder = "data", typ = App {function = Const {name = "List", levels = [Zero]}, arg = Const {name = "Char", levels = []}}, body = Const {name = "String", levels = []}, info = BDefault}) [] (Extern {f = "String.mk", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = Obj}], typ = Obj, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_string_mk"}]}})),("UInt32",ConInfo (Def {name = "UInt32", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["UInt32.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("UInt32.isValidChar",ConInfo (Def {name = "UInt32.isValidChar", levelParams = [], typ = ForAllE {binder = "n", typ = Const {name = "UInt32", levels = []}, body = Sort {level = Zero}, info = BDefault}, kind = Definitional {val = Lam {binder = "n", typ = Const {name = "UInt32", levels = []}, body = App {function = Const {name = "Nat.isValidChar", levels = []}, arg = App {function = Const {name = "UInt32.toNat", levels = []}, arg = Bvar {index = 0}}}, info = BDefault}, safety = Safe}})),("UInt32.mk",DeclT (ForAllE {binder = "toBitVec", typ = App {function = Const {name = "BitVec", levels = []}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 32}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 32}}}}, body = Const {name = "UInt32", levels = []}, info = BDefault}) [] (Extern {f = "UInt32.mk", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = Obj}], typ = U32, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_uint32_of_nat_mk"}]}})),("UInt32.toNat",DeclT (ForAllE {binder = "n", typ = Const {name = "UInt32", levels = []}, body = Const {name = "Nat", levels = []}, info = BDefault}) [] (Extern {f = "UInt32.toNat", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = U32}], typ = Obj, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_uint32_to_nat"}]}})),("UInt64",ConInfo (Def {name = "UInt64", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["UInt64.mk"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("UInt64.mk",DeclT (ForAllE {binder = "toBitVec", typ = App {function = Const {name = "BitVec", levels = []}, arg = App {function = App {function = App {function = Const {name = "OfNat.ofNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = AST.Lit {litVal = AST.N 64}}, arg = App {function = Const {name = "instOfNatNat", levels = []}, arg = AST.Lit {litVal = AST.N 64}}}}, body = Const {name = "UInt64", levels = []}, info = BDefault}) [] (Extern {f = "UInt64.mk", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = Obj}], typ = U64, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_uint64_of_nat_mk"}]}})),("UInt64.ofNatCore",DeclT (ForAllE {binder = "n", typ = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}, body = ForAllE {binder = "h", typ = App {function = App {function = App {function = App {function = Const {name = "LT.lt", levels = [Zero]}, arg = AST.Mdata {dat = AST.MData [("borrowed",AST.DBool True)], body = Const {name = "Nat", levels = []}}}, arg = Const {name = "instLTNat", levels = []}}, arg = Bvar {index = 0}}, arg = Const {name = "UInt64.size", levels = []}}, body = Const {name = "UInt64", levels = []}, info = BDefault}, info = BDefault}) [] (Extern {f = "UInt64.ofNatCore", xs = [Param {x = VarId {idx = 0}, borrow = True, typ = Obj},Param {x = VarId {idx = 1}, borrow = False, typ = Irrelevant}], typ = U64, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_uint64_of_nat"}]}})),("UInt64.size",DeclT (Const {name = "Nat", levels = []}) [] (FDecl {f = "UInt64.size", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "UInt64.size._closed_1", ys = []}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("UInt64.size._closed_1",Decl (FDecl {f = "UInt64.size._closed_1", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Lit {v = N 18446744073709551616}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("instHPow",DeclT (ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u_1")}, body = ForAllE {binder = "\946", typ = Sort {level = Succ (AST.Param "u_2")}, body = ForAllE {binder = "inst._@.Init.Prelude._hyg.3066", typ = App {function = App {function = Const {name = "Pow", levels = [AST.Param "u_1",AST.Param "u_2"]}, arg = Bvar {index = 1}}, arg = Bvar {index = 0}}, body = App {function = App {function = App {function = Const {name = "HPow", levels = [AST.Param "u_1",AST.Param "u_2",AST.Param "u_1"]}, arg = Bvar {index = 2}}, arg = Bvar {index = 1}}, arg = Bvar {index = 2}}, info = BInstance}, info = BImplicit}, info = BImplicit}) ["u_1","u_2"] (FDecl {f = "instHPow", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Irrelevant},Param {x = VarId {idx = 2}, borrow = False, typ = Irrelevant}], typ = Obj, bod = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Pap {c = "instHPow._rarg", ys = []}, b = Ret {r = Var {i = VarId {idx = 3}}}}, info = DeclInfo {sorryDep = Nothing}})),("instHPow._rarg",Decl (FDecl {f = "instHPow._rarg", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj},Param {x = VarId {idx = 3}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Ap {x = VarId {idx = 1}, ys = [Var {i = VarId {idx = 2}},Var {i = VarId {idx = 3}}]}, b = Ret {r = Var {i = VarId {idx = 4}}}}, info = DeclInfo {sorryDep = Nothing}})),("instLTNat",DeclT (App {function = Const {name = "LT", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}) [] (FDecl {f = "instLTNat", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = ECtor {info = CtorInfo {name = "LT.mk", cidx = 0, size = 0, usize = 0, ssize = 0}, ys = []}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("instNatPowNat",DeclT (App {function = Const {name = "NatPow", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}) [] (FDecl {f = "instNatPowNat", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Fap {c = "instNatPowNat._closed_1", ys = []}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("instNatPowNat._closed_1",Decl (FDecl {f = "instNatPowNat._closed_1", xs = [], typ = Obj, bod = Vdecl {x = VarId {idx = 1}, typ = Obj, e = Pap {c = "Nat.pow._boxed", ys = []}, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("instOfNatNat",DeclT (ForAllE {binder = "n", typ = Const {name = "Nat", levels = []}, body = App {function = App {function = Const {name = "OfNat", levels = [Zero]}, arg = Const {name = "Nat", levels = []}}, arg = Bvar {index = 0}}, info = BDefault}) [] (FDecl {f = "instOfNatNat", xs = [Param {x = VarId {idx = 1}, borrow = True, typ = Obj}], typ = Obj, bod = Inc {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 1}}}}, info = DeclInfo {sorryDep = Nothing}})),("instPowNat",DeclT (ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u_1")}, body = ForAllE {binder = "inst._@.Init.Prelude._hyg.3091", typ = App {function = Const {name = "NatPow", levels = [AST.Param "u_1"]}, arg = Bvar {index = 0}}, body = App {function = App {function = Const {name = "Pow", levels = [AST.Param "u_1",Zero]}, arg = Bvar {index = 1}}, arg = Const {name = "Nat", levels = []}}, info = BInstance}, info = BImplicit}) ["u_1"] (FDecl {f = "instPowNat", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Irrelevant}], typ = Obj, bod = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Pap {c = "instPowNat._rarg", ys = []}, b = Ret {r = Var {i = VarId {idx = 2}}}}, info = DeclInfo {sorryDep = Nothing}})),("instPowNat._rarg",Decl (FDecl {f = "instPowNat._rarg", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj},Param {x = VarId {idx = 3}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Ap {x = VarId {idx = 1}, ys = [Var {i = VarId {idx = 2}},Var {i = VarId {idx = 3}}]}, b = Ret {r = Var {i = VarId {idx = 4}}}}, info = DeclInfo {sorryDep = Nothing}})),("mixHash",DeclT (ForAllE {binder = "u\8321", typ = Const {name = "UInt64", levels = []}, body = ForAllE {binder = "u\8322", typ = Const {name = "UInt64", levels = []}, body = Const {name = "UInt64", levels = []}, info = BDefault}, info = BDefault}) [] (Extern {f = "mixHash", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = U64},Param {x = VarId {idx = 1}, borrow = False, typ = U64}], typ = U64, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_uint64_mix_hash"}]}})),("outParam",ConInfo (Def {name = "outParam", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = AST.Param "u"}, body = Sort {level = AST.Param "u"}, info = BDefault}, kind = Definitional {val = Lam {binder = "\945", typ = Sort {level = AST.Param "u"}, body = Bvar {index = 0}, info = BDefault}, safety = Safe}})),("sorryAx",DeclT (ForAllE {binder = "\945", typ = Sort {level = AST.Param "u"}, body = ForAllE {binder = "synthetic", typ = Const {name = "Bool", levels = []}, body = Bvar {index = 1}, info = BDefault}, info = BDefault}) ["u"] (Extern {f = "sorryAx", xs = [Param {x = VarId {idx = 0}, borrow = False, typ = Irrelevant},Param {x = VarId {idx = 1}, borrow = False, typ = U8}], typ = Obj, ext = ExternAttrData {arity = Nothing, entries = [Standard {backend = "all", fn = "lean_sorry"}]}}))]



app :: Decl
app = case Map.lookup "Examples.List.append" listDef of Just (x) -> x; _ -> error "";

rev :: Decl
rev = case Map.lookup "Examples.List.reverse" listDef of Just (x) -> x; _ -> error "";

emp :: Val
emp = VCtor { o = Object { rc = 1, tag = 0 }, vs = [] }

som :: Val
som = VCtor { o = Object { rc = 1, tag = 1 }, vs = [Unsigned 1, VCtor { o = Object { rc = 1, tag = 1 }, vs = [Unsigned 0, emp] }] }

som' :: Val
som' = VCtor { o = Object { rc = 1, tag = 1 }, vs = [Unsigned 0, VCtor { o = Object { rc = 1, tag = 1 }, vs = [Unsigned 1, emp] }] }

listDef :: Map Name Decl
listDef = filterOutDecl $ Map.fromList [("Bool",ConInfo (Def {name = "Bool", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Bool.false","Bool.true"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Bool.false",ConInfo (Def {name = "Bool.false", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Bool.true",ConInfo (Def {name = "Bool.true", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 1, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.List.L",ConInfo (Def {name = "Examples.List.L", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = Sort {level = Succ (AST.Param "u")}, info = BDefault}, kind = Inductive {numParams = 1, numIndices = 0, ctors = ["Examples.List.L.Nil","Examples.List.L.Cons"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("Examples.List.L.Cons",ConInfo (Def {name = "Examples.List.L.Cons", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "a._@.Examples.List._hyg.9", typ = Bvar {index = 0}, body = ForAllE {binder = "a._@.Examples.List._hyg.11", typ = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, body = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 2}}, info = BDefault}, info = BDefault}, info = BImplicit}, kind = Constructor {induct = "Examples.List.L", cidx = 1, numParams = 1, arity = 2, isUnsafe = False}})),("Examples.List.L.Nil",ConInfo (Def {name = "Examples.List.L.Nil", levelParams = ["u"], typ = ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, info = BImplicit}, kind = Constructor {induct = "Examples.List.L", cidx = 0, numParams = 1, arity = 0, isUnsafe = False}})),("Examples.List.append",DeclT (ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "l\8321", typ = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, body = ForAllE {binder = "l\8322", typ = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, body = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 2}}, info = BDefault}, info = BDefault}, info = BImplicit}) ["u"] (FDecl {f = "Examples.List.append", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Irrelevant}], typ = Obj, bod = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Pap {c = "Examples.List.append._rarg._boxed", ys = []}, b = Ret {r = Var {i = VarId {idx = 2}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.List.append._rarg",Decl (FDecl {f = "Examples.List.append._rarg", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = True, typ = Obj}], typ = Obj, bod = Case {tid = "Examples.List.L", x = VarId {idx = 1}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.List.L.Nil", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Inc {x = VarId {idx = 2}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 2}}}}},Ctor {info = CtorInfo {name = "Examples.List.L.Cons", cidx = 1, size = 2, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = IsShared {x = VarId {idx = 1}}, b = Case {tid = "Bool", x = VarId {idx = 3}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Proj {i = 1, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 5}, typ = Obj, e = Fap {c = "Examples.List.append._rarg", ys = [Var {i = VarId {idx = 4}},Var {i = VarId {idx = 2}}]}, b = Set {x = VarId {idx = 1}, i = 1, a = Var {i = VarId {idx = 5}}, b = Ret {r = Var {i = VarId {idx = 1}}}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 6}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 7}, typ = Obj, e = Proj {i = 1, x = VarId {idx = 1}}, b = Inc {x = VarId {idx = 7}, n = 1, c = True, persistent = False, b = Inc {x = VarId {idx = 6}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = Fap {c = "Examples.List.append._rarg", ys = [Var {i = VarId {idx = 7}},Var {i = VarId {idx = 2}}]}, b = Vdecl {x = VarId {idx = 9}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.List.L.Cons", cidx = 1, size = 2, usize = 0, ssize = 0}, ys = [Var {i = VarId {idx = 6}},Var {i = VarId {idx = 8}}]}, b = Ret {r = Var {i = VarId {idx = 9}}}}}}}}}}}]}}}]}, info = DeclInfo {sorryDep = Nothing}})),("Examples.List.append._rarg._boxed",Decl (FDecl {f = "Examples.List.append._rarg._boxed", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj},Param {x = VarId {idx = 2}, borrow = False, typ = Obj}], typ = Obj, bod = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Fap {c = "Examples.List.append._rarg", ys = [Var {i = VarId {idx = 1}},Var {i = VarId {idx = 2}}]}, b = Dec {x = VarId {idx = 2}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 3}}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.List.reverse",DeclT (ForAllE {binder = "\945", typ = Sort {level = Succ (AST.Param "u")}, body = ForAllE {binder = "l", typ = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 0}}, body = App {function = Const {name = "Examples.List.L", levels = [AST.Param "u"]}, arg = Bvar {index = 1}}, info = BDefault}, info = BImplicit}) ["u"] (FDecl {f = "Examples.List.reverse", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Irrelevant}], typ = Obj, bod = Vdecl {x = VarId {idx = 2}, typ = Obj, e = Pap {c = "Examples.List.reverse._rarg", ys = []}, b = Ret {r = Var {i = VarId {idx = 2}}}}, info = DeclInfo {sorryDep = Nothing}})),("Examples.List.reverse._rarg",Decl (FDecl {f = "Examples.List.reverse._rarg", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj}], typ = Obj, bod = Case {tid = "Examples.List.L", x = VarId {idx = 1}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.List.L.Nil", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 2}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.List.L.Nil", cidx = 0, size = 0, usize = 0, ssize = 0}, ys = []}, b = Ret {r = Var {i = VarId {idx = 2}}}}},Ctor {info = CtorInfo {name = "Examples.List.L.Cons", cidx = 1, size = 2, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = U8, e = IsShared {x = VarId {idx = 1}}, b = Case {tid = "Bool", x = VarId {idx = 3}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 4}, typ = Obj, e = Proj {i = 1, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 5}, typ = Obj, e = Fap {c = "Examples.List.reverse._rarg", ys = [Var {i = VarId {idx = 4}}]}, b = Vdecl {x = VarId {idx = 6}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.List.L.Nil", cidx = 0, size = 0, usize = 0, ssize = 0}, ys = []}, b = Set {x = VarId {idx = 1}, i = 1, a = Var {i = VarId {idx = 6}}, b = Vdecl {x = VarId {idx = 7}, typ = Obj, e = Fap {c = "Examples.List.append._rarg", ys = [Var {i = VarId {idx = 5}},Var {i = VarId {idx = 1}}]}, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 7}}}}}}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 9}, typ = Obj, e = Proj {i = 1, x = VarId {idx = 1}}, b = Inc {x = VarId {idx = 9}, n = 1, c = True, persistent = False, b = Inc {x = VarId {idx = 8}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Vdecl {x = VarId {idx = 10}, typ = Obj, e = Fap {c = "Examples.List.reverse._rarg", ys = [Var {i = VarId {idx = 9}}]}, b = Vdecl {x = VarId {idx = 11}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.List.L.Nil", cidx = 0, size = 0, usize = 0, ssize = 0}, ys = []}, b = Vdecl {x = VarId {idx = 12}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.List.L.Cons", cidx = 1, size = 2, usize = 0, ssize = 0}, ys = [Var {i = VarId {idx = 8}},Var {i = VarId {idx = 11}}]}, b = Vdecl {x = VarId {idx = 13}, typ = Obj, e = Fap {c = "Examples.List.append._rarg", ys = [Var {i = VarId {idx = 10}},Var {i = VarId {idx = 12}}]}, b = Dec {x = VarId {idx = 12}, n = 1, c = True, persistent = False, b = Ret {r = Var {i = VarId {idx = 13}}}}}}}}}}}}}}]}}}]}, info = DeclInfo {sorryDep = Nothing}}))]

swap :: Decl
swap = case Map.lookup "Examples.Nat.swap" pairDef of Just (x) -> x; _ -> error "";

mkPair :: Bool -> Val -> Val -> Val
mkPair True  n b = VCtor (Object 1 0) [n, b]
mkPair False b n = VCtor (Object 1 1) [b, n]

pairDef :: Map Text Decl
pairDef = filterOutDecl $ Map.fromList [("Bool",ConInfo (Def {name = "Bool", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Bool.false","Bool.true"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Bool.false",ConInfo (Def {name = "Bool.false", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Bool.true",ConInfo (Def {name = "Bool.true", levelParams = [], typ = Const {name = "Bool", levels = []}, kind = Constructor {induct = "Bool", cidx = 1, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Bool.B",ConInfo (Def {name = "Examples.Bool.B", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Examples.Bool.B.t","Examples.Bool.B.f"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Examples.Bool.B.f",ConInfo (Def {name = "Examples.Bool.B.f", levelParams = [], typ = Const {name = "Examples.Bool.B", levels = []}, kind = Constructor {induct = "Examples.Bool.B", cidx = 1, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Bool.B.t",ConInfo (Def {name = "Examples.Bool.B.t", levelParams = [], typ = Const {name = "Examples.Bool.B", levels = []}, kind = Constructor {induct = "Examples.Bool.B", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Nat.N",ConInfo (Def {name = "Examples.Nat.N", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Examples.Nat.N.Z","Examples.Nat.N.S"], numNested = 0, isRec = True, isUnsafe = False, isReflexive = False}})),("Examples.Nat.N.S",ConInfo (Def {name = "Examples.Nat.N.S", levelParams = [], typ = ForAllE {binder = "a._@.Examples.Nat._hyg.7", typ = Const {name = "Examples.Nat.N", levels = []}, body = Const {name = "Examples.Nat.N", levels = []}, info = BDefault}, kind = Constructor {induct = "Examples.Nat.N", cidx = 1, numParams = 0, arity = 1, isUnsafe = False}})),("Examples.Nat.N.Z",ConInfo (Def {name = "Examples.Nat.N.Z", levelParams = [], typ = Const {name = "Examples.Nat.N", levels = []}, kind = Constructor {induct = "Examples.Nat.N", cidx = 0, numParams = 0, arity = 0, isUnsafe = False}})),("Examples.Nat.P",ConInfo (Def {name = "Examples.Nat.P", levelParams = [], typ = Sort {level = Succ Zero}, kind = Inductive {numParams = 0, numIndices = 0, ctors = ["Examples.Nat.P.fst","Examples.Nat.P.snd"], numNested = 0, isRec = False, isUnsafe = False, isReflexive = False}})),("Examples.Nat.P.fst",ConInfo (Def {name = "Examples.Nat.P.fst", levelParams = [], typ = ForAllE {binder = "a._@.Examples.Nat._hyg.53", typ = Const {name = "Examples.Nat.N", levels = []}, body = ForAllE {binder = "a._@.Examples.Nat._hyg.55", typ = Const {name = "Examples.Bool.B", levels = []}, body = Const {name = "Examples.Nat.P", levels = []}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Examples.Nat.P", cidx = 0, numParams = 0, arity = 2, isUnsafe = False}})),("Examples.Nat.P.snd",ConInfo (Def {name = "Examples.Nat.P.snd", levelParams = [], typ = ForAllE {binder = "a._@.Examples.Nat._hyg.58", typ = Const {name = "Examples.Bool.B", levels = []}, body = ForAllE {binder = "a._@.Examples.Nat._hyg.60", typ = Const {name = "Examples.Nat.N", levels = []}, body = Const {name = "Examples.Nat.P", levels = []}, info = BDefault}, info = BDefault}, kind = Constructor {induct = "Examples.Nat.P", cidx = 1, numParams = 0, arity = 2, isUnsafe = False}})),("Examples.Nat.swap",DeclT (ForAllE {binder = "a._@.Examples.Nat._hyg.95", typ = Const {name = "Examples.Nat.P", levels = []}, body = Const {name = "Examples.Nat.P", levels = []}, info = BDefault}) [] (FDecl {f = "Examples.Nat.swap", xs = [Param {x = VarId {idx = 1}, borrow = False, typ = Obj}], typ = Obj, bod = Case {tid = "Examples.Nat.P", x = VarId {idx = 1}, xType = Obj, cs = [Ctor {info = CtorInfo {name = "Examples.Nat.P.fst", cidx = 0, size = 1, usize = 0, ssize = 1}, b = Vdecl {x = VarId {idx = 2}, typ = U8, e = IsShared {x = VarId {idx = 1}}, b = Case {tid = "Bool", x = VarId {idx = 2}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = SetTag {x = VarId {idx = 1}, cidx = 1, b = Ret {r = Var {i = VarId {idx = 1}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 3}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 4}, typ = U8, e = Sproj {n = 1, offset = 0, x = VarId {idx = 1}}, b = Inc {x = VarId {idx = 3}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Vdecl {x = VarId {idx = 5}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.Nat.P.snd", cidx = 1, size = 1, usize = 0, ssize = 1}, ys = [Var {i = VarId {idx = 3}}]}, b = Sset {x = VarId {idx = 5}, i = 1, offset = 0, y = VarId {idx = 4}, ty = U8, b = Ret {r = Var {i = VarId {idx = 5}}}}}}}}}}]}}},Ctor {info = CtorInfo {name = "Examples.Nat.P.snd", cidx = 1, size = 1, usize = 0, ssize = 1}, b = Vdecl {x = VarId {idx = 6}, typ = U8, e = IsShared {x = VarId {idx = 1}}, b = Case {tid = "Bool", x = VarId {idx = 6}, xType = U8, cs = [Ctor {info = CtorInfo {name = "Bool.false", cidx = 0, size = 0, usize = 0, ssize = 0}, b = SetTag {x = VarId {idx = 1}, cidx = 0, b = Ret {r = Var {i = VarId {idx = 1}}}}},Ctor {info = CtorInfo {name = "Bool.true", cidx = 1, size = 0, usize = 0, ssize = 0}, b = Vdecl {x = VarId {idx = 7}, typ = U8, e = Sproj {n = 1, offset = 0, x = VarId {idx = 1}}, b = Vdecl {x = VarId {idx = 8}, typ = Obj, e = Proj {i = 0, x = VarId {idx = 1}}, b = Inc {x = VarId {idx = 8}, n = 1, c = True, persistent = False, b = Dec {x = VarId {idx = 1}, n = 1, c = True, persistent = False, b = Vdecl {x = VarId {idx = 9}, typ = Obj, e = ECtor {info = CtorInfo {name = "Examples.Nat.P.fst", cidx = 0, size = 1, usize = 0, ssize = 1}, ys = [Var {i = VarId {idx = 8}}]}, b = Sset {x = VarId {idx = 9}, i = 1, offset = 0, y = VarId {idx = 7}, ty = U8, b = Ret {r = Var {i = VarId {idx = 9}}}}}}}}}}]}}}]}, info = DeclInfo {sorryDep = Nothing}}))]
