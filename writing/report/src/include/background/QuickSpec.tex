\section{QuickSpec}\label{sec:quickspec}
QuickSpec~\autocite{Quickspec} is a theory exploration tool.
With a list of functions, with their type signatures annotated, QuickSpec is able to test its way to conjectures using said functions.
Based on these signatures that can be seen in \cref{lst:quickspec_sigs}, one can run QuickSpec on them to retrieve laws such as the ones outlined in \cref{lst:quickspec_result}.
In this example, laws such as commutativity, associativity can be found, but also tautologies, as can be seen in number 8 and 9.

\begin{listing}[H]
\begin{HaskellCode}
signatures :: [Sig]
signatures =
  [ con "0" (0 :: Int)
  , con "+" ((+) :: Int -> Int -> Int)
  , con "not" (not :: Bool -> Bool)
  , con "and" ((&&) :: Bool -> Bool -> Bool)
  , con "or" ((||) :: Bool -> Bool -> Bool)
  ]
\end{HaskellCode}
\caption{Example declaring signatures that QuickSpec can utilize.}
\label{lst:quickspec_sigs}
\end{listing}

\begin{listing}[ht]
\begin{minted}[frame=single, autogobble, fontsize=\small]{fancy}
== Laws ==
  1. x + y = y + x
  2. and x y = and y x
  3. and x x = x
  4. or x y = or y x
  5. or x x = x
  6. x + 0 = x
  7. not (not x) = x
  8. and x (not x) = and y (not y)
  9. or x (not x) = or y (not y)
 10. (x + y) + z = x + (y + z)
 11. and (and x y) z = and x (and y z)
 12. and x (or x y) = x
 13. or x (and x y) = x
 14. or (or x y) z = or x (or y z)
 15. and (not x) (not y) = not (or x y)
 16. and (not x) (or x y) = and y (not x)
 17. and (or x y) (or x z) = or x (and y z)
\end{minted}
\caption{Outputs from running QuickSpec on \cref{lst:quickspec_sigs}.}
\label{lst:quickspec_result}
\end{listing}

Signatures are what QuickSpec relies on to generate conjectures.
For this thesis, the most common signature is \haskell{con}.
\haskell{con} is used to represent a function that should be explored for conjectures.
It may need to be specified on what types that the functions operate on, for example when using polymorphic functions since QuickSpec only allows for monomorphic ones.

When using QuickSpec, the user will have to write a list of signatures themselves.
For usage in Pisa, these signatures will have to be autogenerated, since the user should not have to interact with the Haskell translation.

\subsection{RoughSpec}\label{sec:quickspec:roughspec}
RoughSpec~\autocite{Roughspec} expands on the work in QuickSpec.
RoughSpec allows the user to provide templates of the shape of conjectures, that the user wants to explore.
With these templates, RoughSpec is able to limit the search space more than QuickSpec, since QuickSpec will try to find all applicable laws within the search space.

The syntax of templates can be seen in \cref{lst:roughspec_templates}.
The §?F§ means that there is a meta variable §F§ which is a function, meanwhile §X§ and §Y§ are variables.

\begin{listing}[ht]
\begin{minted}[frame=single, autogobble, fontsize=\small]{fancy}
  ?F X Y = ?F Y X
  ?F (?F X Y) Z = ?F X (?F Y Z)
  ?F (?G X) = X
\end{minted}
\caption
  [Example of RoughSpec templates.]
  {Example of RoughSpec templates for commutativity, associativity, and invertible functions.}
\label{lst:roughspec_templates}
\end{listing}

As an example, using the same functions shown in \cref{lst:quickspec_sigs}, \cref{lst:roughspec_sigs} was created.
Using these, and the templates, one can generate the laws seen in \cref{lst:roughspec_result}.
As one can see, even though the same functions are used as in the QuickSpec example, there are fewer results than \cref{lst:quickspec_result}.
However, one law is found in this example that is not found by QuickSpec, which is \fancy{0 + x = x}.
\fancy{0 + x = x} can be derived from \fancy{x + 0 = x} and \fancy{x + y = y + x}, which why it was discarded by QuickSpec.

One of the more important aspects for RoughSpec is the limitation in search space compared to QuickSpec.
This allows for faster search times for the end user.
Running a test on \cref{lst:roughspec_sigs} on a computer with a AMD Ryzen 7 7735HS, and 16 Gigabytes of RAM at 6400 MHz, in Haskell's interpreter §ghci§, took $0.20$ seconds for RoughSpec and $4.70$ seconds for QuickSpec.

\begin{listing}[H]
\begin{HaskellCode}
signatures :: [Sig]
signatures =
  [ con "0" (0 :: Int)
  , con "+" ((+) :: Int -> Int -> Int)
  , con "not" (not :: Bool -> Bool)
  , con "and" ((&&) :: Bool -> Bool -> Bool)
  , con "or" ((||) :: Bool -> Bool -> Bool)
  , template "comp-id" "?F (?G X) = X"
  , template "op-id-elem" "?F X ?G = X"
  , template "op-elem-id" "?F ?G X = X"
  , template "commutative" "?F X Y = ?F Y X"
  ]
\end{HaskellCode}
\caption{Example declaring signatures that RoughSpec can utilize.}
\label{lst:roughspec_sigs}
\end{listing}

\begin{listing}[H]
\begin{minted}[frame=single, autogobble, fontsize=\small]{fancy}
== Laws ==
Searching for comp-id properties...
  1. not (not x) = x
Searching for op-id-elem properties...
  2. x + 0 = x
Searching for op-elem-id properties...
  3. 0 + x = x
Searching for commutative properties...
  4. x + y = y + x
  5. and x y = and y x
  6. or x y = or y x
\end{minted}
\caption{Outputs from running RoughSpec on \cref{lst:roughspec_sigs}.}
\label{lst:roughspec_result}
\end{listing}

A hybrid system, utilizing both QuickSpec and RoughSpec in tandem, is explored by~\cite{Roughspec}.
This allows QuickSpec to find smaller laws, while also allowing more specified templates for RoughSpec.
RoughSpec is thus able to utilize the more general laws found by QuickSpec, rather than having the user provide general templates.
\citeauthor{Roughspec} note that this helps pruning away larger properties, that are less elegant.
An example of a less elegant property is \haskell{length [] + y = y}, which could expressed with \haskell{length [] = 0} and \haskell{0 + y = y}.
