\section{Polymorphic types}\label{sec:result:poly}
For polymorphic data types, lists and binary trees were defined.
The definitions used, the generated code, and the generated conjectures in lean can be found in \cref{app:poly}.
Using Pisa, the conjectures shown in conjecture set~\ref{eqs:list} and~\ref{eqs:tree} are generated. % An ugly hack, didn't compile correctly otherwise
In the resulting conjectures one can find conjectures regarding inverse function (\cref{reverseinverse,swapinverse}), identity elements (\cref{identityElement1,identityElement2}), associativity (\cref{appendassoc}), fixpoints (\cref{fixpoint1,fixpoint2,swapfixpoint,rightmostfixpoint,leftmostfixpoint}), and combinations of functions that are equal to another function (\cref{defeq1,defeq2}).

To measure the relevance of the generated conjectures for §List§, since §Tree§ doesn't have an equivalent implementation, the following sources of mathlib were used: ``List.Lemmas.reverse'' \autocite{Lemmas.reverse}, ``List.append'' \autocite{List.append}, and ``List.reverse'' \autocite{List.reverse}.
Some of the definitions had to be cut, due to utilizing functions not implemented, or equivalences which is not supported.
The lemmas that is tested against can be seen in \cref{eqs:mathlib_recursive}.
This results in a $TP = 7$, $FP = 2$, $FN = 2$, which means that $Recall = 0.7778$ and $Precision = 0.7778$ for lists.
For the exact list of categorization to generate the values, see \cref{app:overlappolymorphic}.

As mentioned, §Tree§ was not implemented in the same way as mathlib \autocite{Tree}.
The implementation that can be found in mathlib has values in nodes instead of leaves, and the proofs associated are mostly about size and map functions.

\vspace{-0.8cm}
\begin{conjectureset}[H]
\begin{align}
§reverse§\ §Nil§ &= §Nil§ \label{fixpoint1}\\
\forall \alpha : §Type§.\ \forall x : §List§\ \alpha.\ §append§\ x\ §Nil§ &= x \label{identityElement1}\\
\forall \alpha : §Type§.\ \forall x : §List§\ \alpha.\ §append§\ §Nil§\ x &= x \label{identityElement2}\\
\forall \alpha : §Type§.\ \forall x : §List§\ \alpha.\ §reverse§\ (§reverse§\ x) &= x \label{reverseinverse}\\
\forall \alpha : §Type§.\ \forall x : \alpha.\ §reverse§\ (§Cons§\ x\ §Nil§) &= §Cons§\ x\ §Nil§ \label{fixpoint2}\\
\forall \alpha : §Type§.\ \forall x\ y\ z : §List§\ \alpha.\ \nonumber\\
  §append§\ (§append§\ x\ y)\ z &= §append§\ x\ (§append§\ y\ z) \label{appendassoc}\\
\forall \alpha : §Type§.\ \forall x : \alpha.\ \forall y\ z : §List§\ \alpha.\ \nonumber\\
  §Cons§\ x\ (§append§\ y\ z) &= §append§\ (§Cons§\ x\ y)\ z\\
\forall \alpha : §Type§.\ \forall x\ y : §List§\ \alpha.\ \nonumber\\
  §append§\ (§reverse§\ x)\ (§reverse§\ y) &= §reverse§\ (§append§\ y\ x)\\
\forall \alpha : §Type§.\ \forall x : §List§\ \alpha.\ \forall y\ z : \alpha.\ \nonumber\\
  §append§\ x\ (§Cons§\ y\ (§Cons§\ z\ §Nil§)) &= \nonumber \\
  \quad §reverse§\ (§Cons§\ z\ (§Cons§\ y\ (§reverse§\ x)))
\end{align}
\vspace{-0.9cm}
\caption[Generated by Pisa for the domain $§List§\ \alpha$.]{
  Generated by Pisa for the domain $§List§\ \alpha$.
  The Lean versions of these conjectures can be seen in \cref{lst:conjecture:polymorphic:output}.
}\label{eqs:list}
\end{conjectureset}

\vspace{-1.1cm}
\begin{conjectureset}[H]
\begin{align}
\forall \alpha : §Type§.\ \forall x : \alpha.\ §leftmost§\ (§Leaf§\ x) &= x \label{leftmostfixpoint}\\
\forall \alpha : §Type§.\ \forall x : §Tree§\ \alpha.\ §leftmost§\ (§swap§\ x) &= §rightmost§\ x \label{defeq1}\\
\forall \alpha : §Type§.\ \forall x : \alpha.\ §rightmost§\ (§Leaf§\ x) &= x \label{rightmostfixpoint}\\
\forall \alpha : §Type§.\ \forall x : §Tree§\ \alpha.\ §rightmost§\ (§swap§\ x) &= §leftmost§\ x \label{defeq2}\\
\forall \alpha : §Type§.\ \forall x : \alpha.\ §swap§\ (§Leaf§\ x) &= §Leaf§\ x \label{swapfixpoint}\\
\forall \alpha : §Type§.\ \forall x : §Tree§\ \alpha.\ §swap§\ (§swap§\ x) &= x \label{swapinverse}\\
\forall \alpha : §Type§.\ \forall x\ y : §Tree§\ \alpha.\ §leftmost§\ (§Node§\ x\ y) &= §leftmost§\ x\\
\forall \alpha : §Type§.\ \forall x\ y : §Tree§\ \alpha.\ §rightmost§\ (§Node§\ x\ y) &= §rightmost§\ y\\
\forall \alpha : §Type§.\ \forall x\ y : §Tree§\ \alpha.\ §Node§\ (§swap§\ x)\ (§swap§\ y) &= §swap§\ (§Node§\ y\ x)
\end{align}
\vspace{-0.9cm}
\caption[Generated by Pisa for the domain $§Tree§\ \alpha$.]{
  Generated by Pisa for the domain $§Tree§\ \alpha$.
  The Lean versions of these conjectures can be seen in \cref{lst:conjecture:polymorphic2:output}.
}\label{eqs:tree}
\end{conjectureset}

\begin{conjectureset}[H]
\begin{align}
§reverse§\ §[]§ &= §[]§ \\
\forall \alpha : §Type§.\ \forall as : §List§\ \alpha.\ as\ §++§\ §[]§ &= as \\
\forall \alpha : §Type§.\ \forall as : §List§\ \alpha.\ §[]§\ §++§\ as &= as \\
\forall \alpha : §Type§.\ \forall as : §List§\ \alpha.\ as.§reverse§.§reverse§ &= as \\
\forall \alpha : §Type§.\ \forall as\ bs\ cs : §List§\ \alpha.\ \nonumber \\
  (as\ §++§\ bs)\ §++§\ cs &= as\ §++§\ (bs\ §++§\ cs) \\
\forall \alpha : §Type§.\ \forall a : \alpha.\ \forall as\ bs : §List§\ \alpha.\ \nonumber \\
  (a::as)\ §++§\ bs &= a::(as\ §++§\ bs) \\
\forall \alpha : §Type§.\ \forall as\ bs : §List§\ \alpha.\ \nonumber \\
  (as\ §++§\ bs).§reverse§ &= bs.§reverse§\ §++§\ as.§reverse§ \\
\forall \alpha : §Type§.\ \forall as : §List§\ \alpha.\ \forall b : \alpha.\ \forall bs : §List§\ \alpha.\ \nonumber \\
  as\ §++§\ b :: bs &= as\ §++§\ §[§b§]§\ §++§\ bs \\
\forall \alpha : §Type§.\ \forall a : \alpha.\ \forall as : §List§\ \alpha.\ \nonumber \\
  §reverse§\ (a :: as) &= §reverse§\ as\ §++§\ §[§a§]§
\end{align}
\vspace{-0.9cm}
\caption{Mathlib equivalent for the domain $§List§\ \alpha$.}\label{eqs:mathlib_polymorphic}
\end{conjectureset}
