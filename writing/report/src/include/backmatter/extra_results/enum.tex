\section{Enumerated types}\label{app:enum}

\begin{listing}[H]
\begin{LeanCode}
inductive B where | t : B | f : B

def not (b : B) : B :=
  match b with | .t => .f | .f => .t

def and : B → B → B := λ a b =>
  match a with | .t => b | .f => .f

def or : B → B → B := λ
  | .t, _ => .t
  | .f, b => b

#pisa 7 B .t .f not and or
\end{LeanCode}
\caption
  [Benchmark with varying definitions for an enumerated type.]
  {A call to §\#pisa§ on definitions constructed using different approaches to demonstrate its ability to manage a variety code involving an enumerated type, that being booleans.}
\label{lst:conjecture:enum:input}
\end{listing}

\newpage

\begin{listing}[H]
\begin{HaskellCode}
environment :: Map Name Decl
environment = fromList [*\truncated*]

data B where
  B_t :: B
  B_f :: B

toValB :: B -> Val
toValB B_t = Unsigned 0
toValB B_f = Unsigned 1

fromValB :: Val -> B
fromValB (Unsigned 0) -> B_t
fromValB (Unsigned 1) -> B_f

not = FDecl {f = "Example.not", *\truncated*}

and = FDecl {f = "Example.and", *\truncated*}

or = FDecl {f = "Example.or", *\truncated*}

sigs :: [Sig]
sigs =
  [ monoType (Proxy :: Proxy Poly),
    monoType (Proxy :: Proxy B),
    con "B.t" B_t,
    con "B.f" B_f,
    con "not" (\a -> fromValB (eval not environment [toValB a])),
    con "and" (\a b -> fromValB
      (eval and environment [toValB a, toValB b])),
    con "or" (\a b -> fromValB
      (eval or environment [toValB a, toValB b]))
  ]
\end{HaskellCode}
\caption {The auto-generated translation of \cref{lst:conjecture:enum:input}.}
\label{lst:conjecture:enum:code}
\end{listing}

\begin{listing}[H]
\begin{LeanCode}
theorem conjecture0            : not (.f : B) = (.t : B) := sorry
theorem conjecture1            : not (.t : B) = (.f : B) := sorry
theorem conjecture2 (x y : B)  : and x y = and y x := sorry
theorem conjecture3 (x : B)    : and x x = x := sorry
theorem conjecture4 (x y : B)  : or x y = or y x := sorry
theorem conjecture5 (x : B)    : or x x = x := sorry
theorem conjecture6 (x : B)    : and x (.f : B) = (.f : B) := sorry
theorem conjecture7 (x : B)    : and x (.t : B) = x := sorry
theorem conjecture8 (x : B)    : or x (.f : B) = x := sorry
theorem conjecture9 (x : B)    : or x (.t : B) = (.t : B) := sorry
theorem conjecture10 (x : B)   : not (not x) = x := sorry
theorem conjecture11 (x : B)   : and x (not x) = (.f : B) := sorry
theorem conjecture12 (x : B)   : or x (not x) = (.t : B) := sorry
theorem conjecture13 (x y z : B)
  : and x (and y z) = and y (and x z) := sorry
theorem conjecture14 (x y : B) : and x (or x y) = x := sorry
theorem conjecture15 (x y : B) : or x (and x y) = x := sorry
theorem conjecture16 (x y z : B)
  : or x (or y z) = or y (or x z) := sorry
theorem conjecture17 (x y : B)
  : and (not x) (not y) = not (or x y) := sorry
theorem conjecture18 (x y : B)
  : and (not x) (or x y) = and y (not x) := sorry
theorem conjecture19 (x y z : B)
  : and (or x y) (or x z) = or x (and y z) := sorry
theorem conjecture20 (x : B)   : and (.t : B) x = x := sorry
theorem conjecture21 (x : B)   : or (.f : B) x = x := sorry
theorem conjecture22 (x y : B)
  : or (not x) (not y) = not (and x y) := sorry
theorem conjecture23 (x y z : B)
  : and (and x y) z = and x (and y z) := sorry
theorem conjecture24 (x y z : B)
  : or (or x y) z = or x (or y z) := sorry
\end{LeanCode}
\caption
  [Conjectures generated by §\#pisa§ on the code in \cref{lst:conjecture:enum:input}.]
  {Conjectures as generated by invoking the code action on §\#pisa§ in \cref{lst:conjecture:enum:input}.}
\label{lst:conjecture:enum:output}
\end{listing}
