\section{Recursive types}\label{app:recursive}

\begin{listing}[H]
\begin{LeanCode}
inductive N where
  | Z : N
  | S : N → N

def add (n m : N) : N :=
  match m with
  | .Z => n
  | .S m' => .S (add n m')

def mult (n m : N) : N :=
  match m with
  | .Z => .Z
  | .S m' => add n (mult n m')

#pisa 7 N N.Z N.S add mult
\end{LeanCode}
\caption
  [Benchmark with definitions for recursive natural numbers.]
  {Demonstration that §\#pisa§ manage definitions for a recursive type, that being natural numbers.}
\label{lst:conjecture:recursive:input}
\end{listing}

\newpage

\begin{listing}[H]
\begin{HaskellCode}
environment :: Map Name Decl
environment = fromList [*\truncated*]

data N where
  N_Z :: N
  N_S :: N -> N

toValN :: N -> Val
toValN (N_Z)   = VCtor (Object 1 0) []
toValN (N_S b) = VCtor (Object 1 1) [toValN b]

fromValN :: Val -> N
fromValN (VCtor (Object _ 0) [ ]) = N_Z
fromValN (VCtor (Object _ 1) [b]) = N_S (fromValN b)

add = FDecl {f = "Example.add", *\truncated*}

mult = FDecl {f = "Example.mult", *\truncated*}

sigs :: [Sig]
sigs =
  [ monoType (Proxy :: Proxy Poly),
    monoType ((Proxy :: Proxy N)),
    con "N.Z" N_Z,
    con "N.S" N_S,
    con "add" (\a b -> fromValN
      (eval add environment [toValN a, toValN b])),
    con "mult" (\a b -> fromValN
      (eval mult environment [toValN a, toValN b]))
  ]
\end{HaskellCode}
\caption {The auto generated code based on \cref{lst:conjecture:recursive:input}.}
\label{lst:conjecture:recursive:code}
\end{listing}

\begin{listing}[H]
\begin{LeanCode}
theorem conjecture0 (x y : N)    : add x y = add y x := sorry
theorem conjecture1 (x y : N)    : mult x y = mult y x := sorry
theorem conjecture2 (x : N)      : add x (.Z : N) = x := sorry
theorem conjecture3 (x : N)      : mult x (.Z : N) = (.Z : N) := sorry
theorem conjecture4 (x y : N)    : add x (.S y) = .S (add x y) := sorry
theorem conjecture5 (x : N)      : mult x (.S (.Z : N)) = x := sorry
theorem conjecture6 (x y z : N)
  : add x (add y z) = add y (add x z) := sorry
theorem conjecture7 (x y : N)
  : add x (mult x y) = mult x (.S y) := sorry
theorem conjecture8 (x y : N)
  : mult x (add y y) = mult y (add x x) := sorry
theorem conjecture9 (x y z : N)
  : mult x (mult y z) = mult y (mult x z) := sorry
theorem conjecture10 (x y z : N)
  : add (mult x y) (mult x z) = mult x (add y z) := sorry
theorem conjecture11 (x : N)
  : .S (mult x (.S (.S (.S x)))) = add x (mult (.S x) (.S x)) := sorry
theorem conjecture12 (x : N)
  : add (.Z : N) x = x := sorry
theorem conjecture13 (x y z : N)
  : add (add x y) z = add x (add y z) := sorry
theorem conjecture14 (x y z : N)
  : mult (mult x y) z = mult x (mult y z) := sorry
\end{LeanCode}
\caption
  [Conjectures generated by §\#pisa§ on the code in \cref{lst:conjecture:recursive:input}.]
  {Conjectures as generated by invoking the code action on §\#pisa§ in \cref{lst:conjecture:recursive:input}.}
\label{lst:conjecture:recursive:output}
\end{listing}
