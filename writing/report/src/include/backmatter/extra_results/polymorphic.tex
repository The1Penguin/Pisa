\section{Polymorphic types}\label{app:poly}

\vspace{-0.5cm}
\begin{listing}[H]
\begin{LeanCode}
inductive L : Type → Type where
  | Nil : L α
  | Cons : α → L α → L α

def append (xs : L α) (ys : L α) : (L α) :=
  match xs with
  | .Nil => ys
  | .Cons a as => .Cons a (append as ys)

def reverse (l : L α) : (L α) :=
  match l with
  | .Nil => .Nil
  | .Cons a as => append (reverse as) (.Cons a .Nil)

#pisa 7 L L.Nil L.Cons append reverse
\end{LeanCode}
\caption
  [Benchmark with definitions for polymorphic lists.]
  {Demonstration that §\#pisa§ manage definitions for a polymorphic type, that being lists.}
\label{lst:conjecture:polymorphic:input}
\end{listing}

\begin{listing}[H]
\begin{HaskellCode}
environment :: Map Name Decl
environment = fromList [*\truncated*]

data L where
  L_Nil :: L
  L_Cons :: Poly -> L -> L

toValL :: L -> Val
toValL (L_Nil)      = VCtor (Object 1 0) []
toValL (L_Cons b c) = VCtor (Object 1 1) [toValPoly b, toValL c]

fromValL :: Val -> L
fromValL (VCtor (Object _ 0) [   ]) = L_Nil
fromValL (VCtor (Object _ 1) [b,c]) = L_Cons (fromValPoly b) (fromValL c)

append = FDecl {f = "Example.append", *\truncated*}

reverse = FDecl {f = "Example.reverse", *\truncated*}

sigs :: [Sig]
sigs =
  [ monoType (Proxy :: Proxy Poly),
    monoType ((Proxy :: Proxy L)),
    con "L.Nil" L_Nil,
    con "L.Cons" L_Cons,
    con "append" (\a b -> fromValL
      (eval append environment [toValL a, toValL b])),
    con "reverse" (\a -> fromValL (eval reverse environment [toValL a]))
  ]
\end{HaskellCode}
\caption{The auto-generated translation of \cref{lst:conjecture:polymorphic:input}.}
\label{lst:conjecture:polymorphic:code}
\end{listing}

\begin{listing}[H]
\begin{LeanCode}
theorem conjecture0
  : reverse (.Nil : L α) = (.Nil : L α) := sorry
theorem conjecture1 (x : L α) : append x (.Nil : L α) = x := sorry
theorem conjecture2 (x : L α) : append (.Nil : L α) x = x := sorry
theorem conjecture3 (x : L α) : reverse (reverse x) = x := sorry
theorem conjecture4 (x : α)
  : reverse (.Cons x (.Nil : L α)) = .Cons x (.Nil : L α) := sorry
theorem conjecture5 (x y z : L α)
  : append (append x y) z = append x (append y z) := sorry
theorem conjecture6 (x  : α) (y z : L α)
  : .Cons x (append y z) = append (.Cons x y) z := sorry
theorem conjecture7 (x y : L α)
  : append (reverse x) (reverse y) = reverse (append y x) := sorry
theorem conjecture8 (x : L α) (y z : α)
  : append x (.Cons y (.Cons z (.Nil : L α)))
  = reverse (.Cons z (.Cons y (reverse x))) := sorry
\end{LeanCode}
\caption
  [Conjectures generated by §\#pisa§ on the code in \cref{lst:conjecture:polymorphic:input}.]
  {Conjectures as generated by invoking the code action on §\#pisa§ in \cref{lst:conjecture:polymorphic:input}.}
\label{lst:conjecture:polymorphic:output}
\end{listing}


\begin{listing}[H]
\begin{LeanCode}
inductive T (α : Type u) where
  | Leaf : α → T α
  | Node : T α → T α → T α

def swap : T α → T α
  | .Leaf x => .Leaf x
  | .Node l r => .Node (swap r) (swap l)

def leftmost : T α → α
  | .Leaf x => x
  | .Node l _ => leftmost l

def rightmost : T α → α
  | .Leaf x => x
  | .Node _ r => rightmost r

#pisa 7 T T.Leaf T.Node swap leftmost rightmost
\end{LeanCode}
\caption
  [Benchmark with definitions for polymorphic binary trees.]
  {Demonstration that §\#pisa§ manage definitions for a polymorphic type, that being binary trees.}
\label{lst:conjecture:polymorphic2:input}
\end{listing}

\begin{listing}[H]
\begin{HaskellCode}
environment :: Map Name Decl
environment = fromList [*\truncated*]

data T where
  T_Leaf :: Poly -> T
  T_Node :: T -> T -> T

toValT :: T -> Val
toValT (T_Leaf b) = VCtor (Object 1 0) [toValPoly b]
toValT (T_Node b c) = VCtor (Object 1 1) [toValT b, toValT c]

fromValT :: Val -> T
fromValT (VCtor (Object _ 0) [b  ]) = T_Leaf (fromValPoly b)
fromValT (VCtor (Object _ 1) [b,c]) = T_Node (fromValT b) (fromValT c)

swap = FDecl {f = "Example.swap", *\truncated*}

leftmost = FDecl {f = "Example.leftmost", *\truncated*}

rightmost = FDecl {f = "Example.rightmost", *\truncated*}

sigs :: [Sig]
sigs =
  [ monoType (Proxy :: Proxy Poly),
    monoType ((Proxy :: Proxy T)),
    con "T.Leaf" T_Leaf,
    con "T.Node" T_Node,
    con "swap" (\a -> fromValT (eval swap environment [toValT a])),
    con "leftmost" (\a -> fromValPoly
      (eval leftmost environment [toValT a])),
    con "rightmost" (\a -> fromValPoly
      (eval rightmost environment [toValT a]))
  ]
\end{HaskellCode}
\caption{The auto-generated translation of \cref{lst:conjecture:polymorphic2:input}.}
\label{lst:conjecture:polymorphic2:code}
\end{listing}

\begin{listing}[H]
\begin{LeanCode}
theorem conjecture0 (x : α)   : leftmost (.Leaf x) = x := sorry
theorem conjecture1 (x : T α) : leftmost (swap x) = rightmost x := sorry
theorem conjecture2 (x : α)   : rightmost (.Leaf x) = x := sorry
theorem conjecture3 (x : T α) : rightmost (swap x) = leftmost x := sorry
theorem conjecture4 (x : α)   : swap (.Leaf x) = .Leaf x := sorry
theorem conjecture5 (x : T α) : swap (swap x) = x := sorry
theorem conjecture6 (x y : T α)
  : leftmost (.Node x y) = leftmost x := sorry
theorem conjecture7 (x y : T α)
  : rightmost (.Node x y) = rightmost y := sorry
theorem conjecture8 (x y : T α)
  : .Node (swap x) (swap y) = swap (.Node y x) := sorry
\end{LeanCode}
\caption
  [Conjectures generated by §\#pisa§ on the code in \cref{lst:conjecture:polymorphic2:input}.]
  {Conjectures as generated by invoking the code action on §\#pisa§ in \cref{lst:conjecture:polymorphic2:input}.}
\label{lst:conjecture:polymorphic2:output}
\end{listing}
